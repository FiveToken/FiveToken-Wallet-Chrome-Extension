/* eslint-disable new-cap */
import * as CryptoJS from 'crypto-js'
import aesjs from 'aes-js'
const CTRCouterNumber = 6

/*
* Encode privateKey
* PBKDF2 algorithm uses the SHA-256 suite.
* The salt is derived by SHA-256,
* a cryptographic hash function when choosing PBKDF2 interface to set related parameter,
* generated by random interface and stored locally.
* AES algorithm adopts CTR mode encryption.
* @param {string} sk:privateKey
* @param {string} kek: generated by password and salt
* @returns {string}
*/
export function privateKeyEncode (sk, kek) {
  const pk = AESEncrypt(sk, kek)
  return pk
}

/*
* Decode privateKey
* @param {string} encodePrivateKey
* @param {string} kek: generated by password and salt
* @returns {string}
*/
export function privateKeyDecode (encodePrivateKey, kek) {
  const pk = AESDecrypt(encodePrivateKey, kek)
  return pk
}

/*
* Generate salt by password
* @param {string} password
* @returns {string}
*/
export function genSalt (password) {
  const str = `fiveToken${password}`
  const hash = CryptoJS.SHA256(str)
  return hash.toString(CryptoJS.enc.Base64)
}

/*
* Generate kek by password
* @param {string} password
* @returns {string}
*/
export function genKek (password) {
  const salt = genSalt(password)
  const kek = CryptoJS.PBKDF2(password, salt, {
    keySize: 256 / 32
  })
  const kekString = CryptoJS.enc.Base64.stringify(kek)
  return kekString
}

/*
* Encryption
* @param {string} word
* @param {string} key
* @returns {string}
*/
export function AESEncrypt (word, key) {
  const keyMD5 = CryptoJS.MD5(key).toString()
  const keyBytes = aesjs.utils.hex.toBytes(keyMD5)
  const wordBytes = aesjs.utils.utf8.toBytes(word)
  const aesCtr = new aesjs.ModeOfOperation.ctr(keyBytes, new aesjs.Counter(CTRCouterNumber))
  const encryptedData = aesCtr.encrypt(wordBytes)
  const encryptedStr = aesjs.utils.hex.fromBytes(encryptedData)
  return encryptedStr
}

/*
* Decrypt
* @param {string} word
* @param {string} key
* @returns {string}
*/
export function AESDecrypt (encryptedData, key) {
  const keyMD5 = CryptoJS.MD5(key).toString()
  const keyBytes = aesjs.utils.hex.toBytes(keyMD5)
  const encryptedBytes = aesjs.utils.hex.toBytes(encryptedData)
  const aesCtr = new aesjs.ModeOfOperation.ctr(keyBytes, new aesjs.Counter(CTRCouterNumber))
  const decryptedBytes = aesCtr.decrypt(encryptedBytes)
  const decryptedStr = aesjs.utils.utf8.fromBytes(decryptedBytes)
  return decryptedStr
}

// export function skToArray (sk) {
//   const skarr = CryptoJS.enc.Base64.parse(sk)
//   return skarr.words
// }

// export function xor (first, second) {
//   const list = []
//   for (let i = 0; i < first.length; i++) {
//     const ele = first[i]
//     const ele2 = second[i]
//     const res = ele ^ ele2
//     list.push(res)
//   }
//   return list
// }
