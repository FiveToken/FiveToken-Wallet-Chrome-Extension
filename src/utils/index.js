/* eslint-disable camelcase */
import { trim } from 'mytoolkit'
import zxcvbn from 'zxcvbn'
import {
  genT1WalletByMne,
  genT1WalletByCK,
  genPrivateKeyFromMne
} from '@/utils/f1'
import { AddressCheck } from '@/api/proxy'
import { BigNumber } from 'bignumber.js'
import { Wallet } from 'ethers'
import { encryptMessage, encrypt } from './aes-gcm'
/**
 * FiveToken Version
 */
export const fiveTokenVersion = '1.3.0'

/**
 * The smallest unit supported
 */
export const minimumPrecision = 0.00000001

/*
* format number
* @param {string} str: The number that needs to be formatted，Need to be designed for string format
* @param {number} n: number of decimal places reserved
* @returns {string}
*/
export function formatNumber (str, n = 8) {
  const big = bigNumbers(str)
  const limit = big.decimalPlaces(n)
  const value = limit.toFixed()
  return value
}

/*
 * Determine whether to take the node interface
 * @param {string} networkType: chain type
 * @returns {Boolean}
 */
export function isProxy (networkType) {
  return networkType === 'proxy'
}

/*
 * Is it a Filecoin chain
 * @param {string} networkType: chain type
 * @returns {Boolean}
 */
export function isFilecoinChain (networkType) {
  return (networkType === 'proxy' || networkType === 'filecoin')
}

/*
* Generate address and privatekey by mnemonic
* @param {string} mnemonic: 12 words generated by BIP39
* @param {string} password: password
* @param {string} networkType: chain type
* @param {string} filecoinAddress0: The first character of the Filecoin chain address(f,t), ethereum is empty string
* @param {Number} index: generate address index
* @returns {Object}
*/
export async function getF1ByMne (mnemonic, password, networkType, filecoinAddress0, index) {
  if (isFilecoinChain(networkType)) {
    const path = "m/44'/461'/0'/0"
    const ck = genPrivateKeyFromMne(mnemonic, path, index)
    const f1 = genT1WalletByMne(ck, filecoinAddress0)
    const { address, privateKey } = f1
    const senderPublicKey = await encrypt(password, address)
    const encryptMnemonic = await encrypt(mnemonic, address)
    const encryptKey = await encryptMessage(privateKey, senderPublicKey, address)
    return {
      address,
      privateKey: encryptKey,
      mnemonic: encryptMnemonic
    }
  } else {
    const path = "m/44'/60'/0'/0"
    const ck = await genPrivateKeyFromMne(mnemonic, path, index)
    const pk = ck.toString('hex')
    const f1 = new Wallet(pk)
    const { address, privateKey } = f1
    const senderPublicKey = await encrypt(password, address)
    const encryptMnemonic = await encrypt(mnemonic, address)
    const encryptKey = await encryptMessage(privateKey, senderPublicKey, address)
    return {
      address,
      privateKey: encryptKey,
      mnemonic: encryptMnemonic
    }
  }
}

/*
* Generate address by privateKey
* @param {string} privateKey: encrypted privatekey
* @param {string} password: password
* @param {string} networkType: chain type
* @param {string} filecoinAddress0: The first character of the Filecoin chain address(f,t), ethereum is empty string
* @returns {Object}
*/
export async function getF1ByPrivateKey (privateKey, password, networkType, filecoinAddress0) {
  try {
    if (isFilecoinChain(networkType)) {
      const f1 = genT1WalletByCK(privateKey, filecoinAddress0, [])
      const { address } = f1
      const senderPublicKey = await encrypt(password, address)
      const pk = await encryptMessage(privateKey, senderPublicKey, address)
      return {
        address,
        privateKey: pk
      }
    } else {
      const walletMnemonic = new Wallet(privateKey)
      const { address } = walletMnemonic
      const senderPublicKey = await encrypt(password, address)
      const pk = await encryptMessage(privateKey, senderPublicKey, address)
      return {
        address,
        privateKey: pk
      }
    }
  } catch (err) {
    return null
  }
}

/*
* Generate address by privateKey
* @param {string} encodePrivateKey: encrypted privatekey
* @param {string} networkType: chain type
* @returns {string}
*/
export function getBackupsPrivateKey (encodePrivateKey, networkType) {
  if (isFilecoinChain(networkType)) {
    const privateKey = strToHexCharCode(encodePrivateKey)
    return privateKey
  } else {
    return encodePrivateKey
  }
}

/*
* Hex privateKey
* @param {string} privateKey
* @returns {string}
*/
export function strToHexCharCode (pk) {
  if (pk === '') return ''
  const obj = {
    Type: 'secp256k1',
    PrivateKey: pk
  }
  const str = JSON.stringify(obj)
  const hexCharCode = []
  for (let i = 0; i < str.length; i++) {
    hexCharCode.push((str.charCodeAt(i)).toString(16))
  }
  return hexCharCode.join('')
}

/*
* get url parameters
* @param {string} parameters key
* @returns {string}
*/
export function getQueryString (name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i')
  const r = window.location.search.substr(1).match(reg)
  if (r != null) return unescape(r[2])
  return null
}

/*
* convert timestamp to time
* @param {number} timestamp
* @param {Boolean} second: add hours, minutes and seconds
* @returns {string}
*/
export function formatDate (timestamp, second) {
  if (timestamp === '') return
  const date = new Date(timestamp * 1000)
  const y = date.getFullYear()
  const m = date.getMonth() + 1
  const d = date.getDate()
  const h = date.getHours()
  const mm = date.getMinutes()
  const s = date.getSeconds()
  if (second) {
    return y + '-' + add0(m) + '-' + add0(d) + ' ' + add0(h) + ':' + add0(mm) + ':' + add0(s)
  } else {
    return y + '-' + add0(m) + '-' + add0(d)
  }
}

/*
* Format number
* @param {number} m
*/
export function add0 (m) { return m < 10 ? '0' + m : m }

export function parseE (str) {
  if (!/[eE][+-]\d+$/.test(str)) {
    return str
  }
  str = String(str).toLowerCase()
  let [n, p] = str.split('e')
  const sign = p[0]
  const len = Number(p.slice(1))
  let r = ''
  if (sign === '+') {
    r = '1'
    for (let i = 0; i < len; i++) {
      r += '0'
    }
    n = n.replace('.', '')
    r = n + r.slice(n.length)
  } else {
    r = '0.'
    for (let i = 0; i < len; i++) {
      r += '0'
    }
    n = n.replace(/^0/, '')
    n = n.replace('.', '')
    r = r.slice(0, r.length - 1) + n
  }
  return r
}

/*
* Check address validity
* @param {number} v:address
* @param {string} networkType: chain type
* @returns {Boolean}
*/
export async function isValidAddress (address, networkType) {
  const trim = trimStr(address)
  if (isFilecoinChain(networkType)) {
    const rpc = 'https://api.fivetoken.io'
    const res = await AddressCheck(trim, rpc)
    if (res.code === 200 && res.data === 'ok') {
      return true
    } else {
      return false
    }
  } else {
    const reg = /^0x[0-9A-Fa-f]{40}$/
    const bol = reg.test(trim)
    return bol
  }
}

/*
* remove the leading and trailing spaces of the string
* @param {string} str
* @returns {string}
*/
export function trimStr (str) {
  return str.replace(/(^\s*)|(\s*$)/g, '')
}

/*
* Returns a new instance of a BigNumber
* @param {string} val
* @returns {BigNumber}
*/
export function bigNumbers (val) {
  return new BigNumber(val)
}

export function fil2atto (v) {
  v = trim(String(v + ''))
  if (!isDecimal(v)) {
    return ''
  }
  v = v * Math.pow(10, 18)
  return parseE(v.toFixed(0))
}

export function isDecimal (str) {
  const r = /(^\d+(?:\.\d+)?([eE]-?\d+)?$|^\.\d+([eE]-?\d+)?$)/
  return r.test(str)
}

export function zxcvbnFun (str) {
  const res = zxcvbn(str)
  return res.score
}

export function routePush (url, params) {
  if (params != null) {
    url = url + jsonToString(params)
  }
  window.location.href = url
}

export function jsonToString (obj) {
  const arr = []
  for (const key in obj) {
    arr.push(key + '=' + obj[key])
  }
  return arr.join('&')
}

export function isValidPass (str) {
  const reg = /^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\d)(?=.*?[~`！@#$%^&*()_–+={[}]|：;“'<,>.?])[a-zA-Z\d~`！@#$%^&*()_–+={[}]|：;“'<,>.?]{9,}.*$/
  return reg.test(str)
}

export function reverse (str) {
  return str.split('').reverse().join('')
}
