/* eslint-disable camelcase */

import * as CryptoJS from 'crypto-js'
// import sha256 from 'crypto-js/sha256';
import blake from 'blakejs'
import * as bip39 from 'bip39'
import base32Encode from 'base32-encode'
import { Buffer } from 'buffer'
import hdkey from 'ethereumjs-wallet/hdkey'
import * as ethutil from 'ethereumjs-util'

/*
* Generate address and privatekey by mnemonic
* @param {string} mne: 12 words generated by BIP39
* @param {string} filecoinAddress0: The first character of the Filecoin chain address(f,t), ethereum is empty string
* @param {string} path: generate address path
* @param {Number} index: generate address index
* @returns {Object}
*/
export function genT1WalletByMne (ck, filecoinAddress0) {
  const privateKey = ck.toString('base64')
  const publicKey = privateToPublicKey(ck)
  let address = getAddressByPublicKey(publicKey)
  address = `${filecoinAddress0}1${address}`
  return {
    address,
    privateKey
  }
}

/*
 * @param {string} ck
 * @param {*} filecoinAddress0 :The first character of the Filecoin chain address(f,t), ethereum is empty string
 * @returns {Object}
 */
export function genT1WalletByCK (ck, filecoinAddress0) {
  const pk = Buffer.from(ck, 'base64')
  const publicKey = ethutil.privateToPublic(pk)
  let address = getAddressByPublicKey(publicKey)
  address = `${filecoinAddress0}1${address}`
  return {
    address,
    privateKey: ck
  }
}

/*
* Generate ArrayBuffer
* @param {string} mne: 12 words generated by BIP39
* @param {string} path: generate address path
* @param {Number} index: generate address index
* @returns {ArrayBuffer}
*/
export function genPrivateKeyFromMne (mne, path, index) {
  // m/44'/461'/0'/0
  // m/44'/60'/0'/0
  const fileCoinDerivePath = path
  const seed = bip39.mnemonicToSeedSync(mne)
  const rootKey = hdkey.fromMasterSeed(seed)
  const deriveKey = rootKey.derivePath(fileCoinDerivePath)
  const k0 = deriveKey.deriveChild(index)
  return Buffer.from(k0._hdkey._privateKey)
}

/*
 * Use private key to generate public key
 * @param {ArrayBuffer} ck
 * @returns {ArrayBuffer}
 */
export function privateToPublicKey (ck) {
  return ethutil.privateToPublic(ck)
}

/*
 * Use pubkey generate address
 * @param {ArrayBuffer} ck
 * @returns {string}
 */
export function getAddressByPublicKey (pubkey) {
  const pk = Array.from(pubkey)
  pk.unshift(4)
  const address = blake2b(Uint8Array.from(pk), 20)
  const add = Array.from(address)
  add.unshift(1)
  const cksm = blake2b(Uint8Array.from(add), 4)
  const addressArr = Array.from(address)
  const cksmArr = Array.from(cksm)
  const addrBuff = Uint8Array.from(addressArr.concat(cksmArr))
  return base32Encode(addrBuff, 'RFC4648', {
    padding: false
  }).toLowerCase()
}

/*
 * Intercept the specified length ArrayBuffer
 * @param {ArrayBuffer} arr
 * @param {number} len
 * @returns {ArrayBuffer}
 */
export function blake2b (arr, len) {
  return blake.blake2b(arr, null, len)
}

/*
 * Use privateKey generate digest
 * @param {string} privateKey
 * @returns { string }
 */
export async function genPrivateKeyDigest (privateKey) {
  const digest = CryptoJS.SHA256(privateKey).toString(CryptoJS.enc.Base64)
  return digest.substring(0, 16)
}

// export function skToArray (sk) {
//   const skarr = CryptoJS.enc.Base64.parse(sk)
//   return skarr.words
// }

// export function xor (first, second) {
//   const list = []
//   for (let i = 0; i < first.length; i++) {
//     const ele = first[i]
//     const ele2 = second[i]
//     const res = ele ^ ele2
//     list.push(res)
//   }
//   return list
// }
